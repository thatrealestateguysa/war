/**
 * Web handler for the dashboard.
 * URL params:
 *   action=all
 *   suburbs=Paulshof,Lonehill  (optional)
 *   platform=All|Property24... (optional)
 *   entityType=All|Agent|Agency (optional)
 *   callback=cb                (optional, for JSONP)
 */
function doGet(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Master_Data');
    if (!sheet) return _out({ success:false, error:'Sheet "Master_Data" not found.' }, e);

    const values = sheet.getDataRange().getValues();
    if (!values || values.length < 2) return _out({ success:false, error:'No data rows in Master_Data.' }, e);

    const headers = values[0].map(String);
    const rows = values.slice(1);

    // Column index helpers (tolerant to missing optional columns)
    const idx = (name, fallback) => {
      const i = headers.indexOf(name);
      if (i === -1 && fallback !== undefined) return fallback;
      if (i === -1) throw new Error('Missing column: ' + name);
      return i;
    };

    const iSuburb     = idx('Suburb');
    const iPlatform   = idx('Platform');
    const iEntityType = idx('EntityType');
    const iName       = idx('Name');
    const iMetric     = idx('Metric');
    const iCount      = idx('Count');
    const iAgency     = headers.indexOf('Agency'); // optional

    // Parse filters
    const qp = e && e.parameter ? e.parameter : {};
    const action     = (qp.action || 'all').toLowerCase();
    const platform   = qp.platform || 'All';
    const entityType = qp.entityType || 'All';
    const suburbsSel = (qp.suburbs || '').split(',').map(s => s.trim()).filter(Boolean);

    // Build filter options from ALL data (not filtered)
    const setSuburbs  = new Set();
    const setPlatforms= new Set();
    const setEntities = new Set();
    rows.forEach(r => {
      setSuburbs.add(r[iSuburb]);
      setPlatforms.add(r[iPlatform]);
      setEntities.add(r[iEntityType]);
    });
    const filters = {
      suburbs:   Array.from(setSuburbs).sort(),
      platforms: Array.from(setPlatforms).sort(),
      entityTypes: Array.from(setEntities).sort(),
      metrics: ['Active Listings', 'Sold', 'Under Offer', 'Total Sales']
    };

    // Apply incoming filters
    const filtered = rows.filter(r => {
      if (suburbsSel.length && !suburbsSel.includes(String(r[iSuburb]))) return false;
      if (platform !== 'All'   && String(r[iPlatform])   !== platform)   return false;
      if (entityType !== 'All' && String(r[iEntityType]) !== entityType) return false;
      return true;
    });

    // Aggregate totals per Suburb + Person/Agency
    const asNumber = (v) => Number(v) || 0;

    // ---- AGENTS ----
    const agentAgg = new Map(); // key: suburb|name|agency
    filtered
      .filter(r => String(r[iEntityType]) === 'Agent')
      .forEach(r => {
        const suburb = String(r[iSuburb]);
        const name   = String(r[iName]);
        const agency = (iAgency !== -1 ? String(r[iAgency]) : '');
        const metric = String(r[iMetric]);
        const count  = asNumber(r[iCount]);
        const key = [suburb, name, agency].join('|');

        if (!agentAgg.has(key)) agentAgg.set(key, {
          suburb, agent:name, agency,
          activeListings:0, sold:0, underOffer:0, totalSales:0
        });
        const obj = agentAgg.get(key);
        if (metric === 'Active Listings') obj.activeListings += count;
        if (metric === 'Sold')            obj.sold          += count;
        if (metric === 'Under Offer')     obj.underOffer    += count;
        obj.totalSales = obj.sold + obj.underOffer;
      });

    // top agents per suburb (listings)
    const bySuburbAgent = Array.from(agentAgg.values()).reduce((m, r) => {
      if (!m[r.suburb]) m[r.suburb] = [];
      m[r.suburb].push(r);
      return m;
    }, {});
    const TopAgentsListings = Object.keys(bySuburbAgent).map(suburb => {
      const best = bySuburbAgent[suburb].slice().sort((a,b)=>b.activeListings - a.activeListings)[0];
      return best ? { suburb, agent:best.agent, agency:best.agency, activeListings:best.activeListings } : null;
    }).filter(Boolean);

    // top agents per suburb (sales)
    const TopAgentsSales = Object.keys(bySuburbAgent).map(suburb => {
      const best = bySuburbAgent[suburb].slice().sort((a,b)=> (b.totalSales - a.totalSales) || (b.sold - a.sold) )[0];
      return best ? {
        suburb, agent:best.agent, agency:best.agency,
        sold:best.sold, underOffer:best.underOffer, totalSales:best.totalSales
      } : null;
    }).filter(Boolean);

    // ---- AGENCIES ----
    const agencyAgg = new Map(); // key: suburb|agency
    filtered
      .filter(r => String(r[iEntityType]) === 'Agency')
      .forEach(r => {
        const suburb = String(r[iSuburb]);
        const agency = iAgency !== -1 ? String(r[iAgency]) : String(r[iName]); // fallback to Name
        const metric = String(r[iMetric]);
        const count  = asNumber(r[iCount]);
        const key = [suburb, agency].join('|');

        if (!agencyAgg.has(key)) agencyAgg.set(key, {
          suburb, agency,
          activeListings:0, sold:0, underOffer:0, totalSales:0
        });
        const obj = agencyAgg.get(key);
        if (metric === 'Active Listings') obj.activeListings += count;
        if (metric === 'Sold')            obj.sold          += count;
        if (metric === 'Under Offer')     obj.underOffer    += count;
        obj.totalSales = obj.sold + obj.underOffer;
      });

    // top agency per suburb (active & sales)
    const bySuburbAgency = Array.from(agencyAgg.values()).reduce((m, r) => {
      if (!m[r.suburb]) m[r.suburb] = [];
      m[r.suburb].push(r);
      return m;
    }, {});
    const TopAgencies = Object.keys(bySuburbAgency).map(suburb => {
      const list = bySuburbAgency[suburb];
      const topActive = list.slice().sort((a,b)=>b.activeListings - a.activeListings)[0];
      const topSales  = list.slice().sort((a,b)=>b.totalSales    - a.totalSales)[0];
      return {
        suburb,
        topAgencyActive: topActive ? topActive.agency : '',
        activeListings:  topActive ? topActive.activeListings : 0,
        topAgencySales:  topSales  ? topSales.agency  : '',
        totalSales:      topSales  ? topSales.totalSales : 0
      };
    });

    // ---- Recruit targets (exclude KW brands) ----
    const excludeKW = (s) => (s||'').toLowerCase().includes('keller') || (s||'').toLowerCase().includes('kw');
    const targets = Array.from(agentAgg.values())
      .filter(r => !excludeKW(r.agency))
      .map(r => {
        const strength = r.totalSales > r.activeListings ? 'Sales' :
                         r.activeListings > r.totalSales ? 'Listings' : 'Balanced';
        return { ...r, strength };
      });

    // take the top 3 per suburb by totalSales, then by activeListings
    const RecruitTargets = Object.keys(bySuburbAgent).flatMap(suburb => {
      return targets
        .filter(t => t.suburb === suburb)
        .sort((a,b)=> (b.totalSales - a.totalSales) || (b.activeListings - a.activeListings))
        .slice(0, 3);
    });

    const payload = {
      success: true,
      updatedAt: new Date().toISOString(),
      filters,
      summaries: { TopAgentsListings, TopAgentsSales, TopAgencies, RecruitTargets }
    };

    return _out(payload, e);

  } catch (err) {
    return _out({ success:false, error:String(err) }, e);
  }
}

/** JSON/JSONP output helper */
function _out(obj, e) {
  const cb = e && e.parameter && e.parameter.callback;
  const text = cb ? (cb + '(' + JSON.stringify(obj) + ');') : JSON.stringify(obj);
  const out = ContentService.createTextOutput(text);
  out.setMimeType(cb ? ContentService.MimeType.JAVASCRIPT : ContentService.MimeType.JSON);
  return out;
}
